<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://cjycathy.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="cn">
<meta property="article:author" content="Jinyi Cai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cjycathy.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="posts-Web前端面试——HTTP部分" class="article article-type-posts" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/28/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94HTTP%E9%83%A8%E5%88%86/" class="article-date">
  <time datetime="2020-03-28T12:50:53.000Z" itemprop="datePublished">2020-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/28/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94HTTP%E9%83%A8%E5%88%86/">Web前端面试——HTTP部分</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="TCP-IP的三次握手和四次挥手"><a href="#TCP-IP的三次握手和四次挥手" class="headerlink" title="TCP/IP的三次握手和四次挥手"></a>TCP/IP的三次握手和四次挥手</h3><p>三次握手的必要性：为了保证<strong>服务器能接收到客户端的信息并做出正确的应答</strong>而进行前两次（第一次和第二次）握手，为了保证<strong>客户端能够接收到服务端的信息并能做出正确的应答</strong>而进行后两次（第二次和第三次）握手。</p>
<p>三次握手:   </p>
<p>报文首部有TCP的6种标示:<strong>SYN(建立联机) ACK(确认)</strong> PSH(传送) <strong>FIN(结束)</strong> RST(重置) URG(紧急)<br><img src="https://img-blog.csdnimg.cn/20200307225354210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbGRnaXJseQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>第一次握手：客户端向服务器发出连接请求报文，这时报文首部中包含<strong>SYN码</strong>，表示客户端要求和服务端建立连接；<ul>
<li>第二次握手：服务端收到客户端的连接请求后，会发出含有<strong>ACK码</strong>的响应报文给客户端，表示你的连接请求已经收到，<strong>询问客户端是否真的需要建立连接</strong>；</li>
<li>第三次握手：客户端收到ACK码以后会<strong>检验是否正确</strong>，如果正确，客户端会再次发送<strong>ACK码</strong>的报文给服务端，<strong>表示确认建立连接</strong>；</li>
</ul>
</li>
</ul>
<blockquote>
<p>   三次握手都成功以后才会建立连接，然后才会发送数据；</p>
</blockquote>
<p>四次挥手：<br><img src="https://img-blog.csdnimg.cn/20200307230110638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbGRnaXJseQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>第一次挥手：当客户端发送数据结束后，会发送<strong>FIN码</strong>数据包给服务端，表示告知服务端客户端的<strong>数据已经传递完</strong>了。<ul>
<li>第二次挥手：当服务端收到FIN后，会发送<strong>ACK</strong>给客户端，表示<strong>服务端已经知道客户端传完</strong>了。客户端收到ACK以后就会<strong>把传递数据给服务端的通道关闭</strong>；</li>
<li>第三次挥手：当服务端把响应的数据发送完毕后，会发送一个<strong>FIN</strong>给客户端，告知客户端<strong>响应的数据已经发送完毕</strong>；</li>
<li>第四次挥手：当客户端收到FIN后，会发送一个<strong>ACK码</strong>数据包给服务端，告知服务端客户端已经知道数据发送完毕；服务端收到ACK码后，可以安心的把<strong>数据传递通道关闭掉</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>发送FIN表示数据已经发送完，接收到ACK码后这一方才会把通道关闭</p>
</blockquote>
<h3 id="HTTP有哪些方法？"><a href="#HTTP有哪些方法？" class="headerlink" title="HTTP有哪些方法？"></a>HTTP有哪些方法？</h3><ul>
<li>HTTP/1.0定义了三种请求方法： GET, POST 和 HEAD方法</li>
<li>HTTP/1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT</li>
<li>HTTP/2 新增：PATCH</li>
</ul>
<ol>
<li><strong>GET：获取资源</strong><br> GET 方法用来请求访问已被 URI 识别的资源</li>
<li><strong>POST：传输实体主体</strong></li>
<li><strong>HEAD：获得报文首部</strong></li>
<li><strong>PUT：传输文件</strong><br> 就像 FTP 协议的文件上传一样,要求在请求报文的主体中包含文件内容,然后保存到请求 URI 指定的位置</li>
<li><strong>DELETE：删除文件</strong><br> DELETE 方法用来删除文件,是与 PUT 相反的方法。</li>
<li><strong>OPTIONS：询问支持的方法</strong><br> OPTIONS 方法用来查询服务器支持的方法</li>
<li><strong>TRACE：追踪路径</strong><br> TRACE 方法用来确认连接过程中发生的一系列操作，用于测试或诊断</li>
<li><strong>CONNECT：要求用隧道协议连接代理</strong><br> CONNECT 方法要求在与代理服务器通信时建立隧道,实现用隧道协议进行 TCP 通信。主要使用 SSL(安全套接层)和 TLS(传输层安全)协议把通信内容加密后经网络隧道传输</li>
<li><strong>PATCH: 用于对资源进行部分修改</strong><h3 id="http常用状态码-http-status-code"><a href="#http常用状态码-http-status-code" class="headerlink" title="http常用状态码(http-status-code):"></a>http常用状态码(http-status-code):</h3></li>
</ol>
<ul>
<li>1XX 信息状态码</li>
<li>2XX 成功状态码 0, 4, 6</li>
</ul>
<ol>
<li>200 OK<pre><code>表示从客户端发来的请求在服务器端被**正常处理**了</code></pre></li>
<li>204 No Content<pre><code>该状态码代表服务器接收的请求已成功处理,但在返回的响应报文中**不含实体的主体部分**，就是服务端没有内容返回。一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用</code></pre></li>
<li>206 Partial Content<pre><code>该状态码表示客户端进行了**范围请求**,而服务器成功执行了这部分的 GET 请求，响应报文中包含由**Content-Range** 指定范围的实体内容</code></pre></li>
</ol>
<ul>
<li>3XX 重定向状态码 1, 2, 3, 4, 7</li>
</ul>
<ol>
<li>301 Moved Permanently<pre><code>永久性重定向。该状态码表示请求的资源已被**分配了新的 URI**,以后应使用资源现在所指的 URI。</code></pre></li>
<li>302 Found<pre><code>临时性重定向。该状态码表示请求的资源已被分配了新的 URI,希望用户**本次**能使用新的 URI 访问。但 302 状态码代表的资源不是被永久移动，只是临时性质的。即已移动的资源对应的 URI 将来还有可能发生改变。</code></pre></li>
<li>303 See Other<pre><code>该状态码表示由于请求对应的资源存在着另一个 URI,应使用 **GET 方法**定向获取请求的资源
    303 状态码和 302 Found 状态码有着相同的功能,但 303 状态码明确表示客户端应当采用 GET 方法获取资源</code></pre></li>
<li>304 Not Modified<pre><code>**走缓存**(服务端觉得你之前请求过这个东西,而且服务器上的那一份没有发生变化,告诉客户端用缓存就行)</code></pre></li>
<li>307 Temporary Redirect<pre><code>临时重定向。该状态码与 302 Found 有着相同的含义。在**重定向时不会改变 method**</code></pre></li>
</ol>
<ul>
<li>4XX 客户端错误状态码 0, 1, 3, 4</li>
</ul>
<ol>
<li>400 Bad Request<pre><code>该状态码表示请求报文中存在**语法错误**</code></pre></li>
<li>401 Unauthorized<pre><code>该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的**认证信息**。权限不够导致的</code></pre></li>
<li>403 Forbidden<br>  该状态码表明对请求资源的访问<strong>被服务器拒绝</strong>了，没有说明具体原因</li>
<li>404 Not Found<br>  该状态码表明服务器上<strong>无法找到请求的资源</strong>，客户端请求的资源或者数据不存在</li>
</ol>
<ul>
<li>5XX 服务器错误状态码 0, 3</li>
</ul>
<ol>
<li>500 Internal Server Error<br>  该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障，<strong>服务器内部错误</strong></li>
<li>503 Service Unavailable<br>  该状态码表明服务器暂时处于<strong>超负载或正在进行停机维护</strong>,现在无法处理请求</li>
</ol>
<h3 id="从浏览器输入URL按回车到页面显示都发生了什么"><a href="#从浏览器输入URL按回车到页面显示都发生了什么" class="headerlink" title="从浏览器输入URL按回车到页面显示都发生了什么?"></a>从浏览器输入URL按回车到页面显示都发生了什么?</h3><ol>
<li>查询IP地址。浏览器根据URL进行<strong>DNS查询</strong>取得IP地址（DNS 查询：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS 缓存-&gt;根域名服务器）</li>
<li>与服务器连接。<br>(1) 构造HTTP请求，添加一些HTTP首部，<strong>建立TCP连接</strong>（三次握手）<br>(2) 浏览器向web服务器<strong>发送HTTP请求报文</strong>，等待响应<br>(3) 服务器处理HTTP请求报文，<strong>返回响应报文</strong><br>(4) 首先浏览器会判断<strong>状态码</strong>是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错</li>
<li>渲染页面。如果是200，浏览器解析服务器返回的HTTP响应报文，若为HTML则<strong>渲染页面</strong>。<br>先会根据 HTML 构建 <strong>DOM 树</strong>，有 CSS 的话会去构建 <strong>CSSOM 树</strong>。<br>遇到 script 标签，判断是否存在 <strong>async</strong> 或者 <strong>defer</strong> ，前者会<strong>并行进行下载并执行 JS</strong>，后者会<strong>先下载文件，然后等待 HTML 解析完成后顺序执行</strong>，如果以上都没有，就会阻塞住渲染流程，<strong>先执行JS</strong>。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。<br>CSSOM 树和 DOM 树构建完成后会开始生成 <strong>Render 树</strong>，这一步就是确定页面<strong>元素的布局</strong>、<strong>样式</strong>等等<br>在生成 Render 树的过程中，浏览器就开始调用 <strong>GPU 绘制</strong>，合成图层，将内容<strong>显示</strong>在屏幕上了<ol start="7">
<li>最后<strong>关闭TCP连接</strong>（四次挥手）</li>
</ol>
</li>
</ol>
<p>参考<br><a href="https://www.jianshu.com/p/fc95603b8cf0" target="_blank" rel="noopener">从输入url到页面加载完成发生了什么？——前端角度</a></p>
<h3 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别?"></a>HTTPS和HTTP的区别?</h3><p>HTTP(Hyper Text Transfer Protocol)超文本传输协议，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议<br>HTTPS协议是由SSL(Secure Socket Layer)+HTTP协议构建的可进行<strong>加密传输、身份认证</strong>的网络协议，要比http协议安全。</p>
<ol>
<li>HTTPS协议需要到ca申请<strong>证书</strong>，一般免费证书较少，因而需要一定费用。</li>
<li>HTTP是超文本传输协议，信息是<strong>明文传输</strong>，HTTPS则是具有安全性的<strong>SSL加密传输</strong>协议。</li>
<li>HTTP和HTTPS使用的是完全不同的<strong>连接方式</strong>，用的<strong>端口</strong>也不一样，前者是<strong>80</strong>，后者是<strong>443</strong>。</li>
<li>HTTP的连接很简单，是<strong>无状态的</strong>；HTTPS协议是由SSL+HTTP协议构建的可进行<strong>加密传输、身份认证</strong>的网络协议，比HTTP协议安全。</li>
</ol>
<p>HTTPS主要解决三个安全问题：</p>
<ol>
<li>内容隐私</li>
<li>防篡改</li>
<li>确认对方身份<br>https并不是直接通过非对称加密传输过程，而是有握手过程，握手过程主要是和服务器做通讯，生成私有密钥，最后通过该密钥对称加密传输数据。还有验证证书的正确性。 证书验证过程保证了对方是合法的，并且中间人无法通过伪造证书方式进行攻击。</li>
</ol>
<h3 id="什么是HTTP持久化和管线化"><a href="#什么是HTTP持久化和管线化" class="headerlink" title="什么是HTTP持久化和管线化"></a>什么是HTTP持久化和管线化</h3><p>出现背景： HTTP 最初的版本中，每进行一次 HTTP 通信，就要断开一次 TCP 连接（无连接）<br>为解决上述问题，HTTP/1.1 增加了持久连接（HTTP Persistent Connections ）的方法，其特点是，<strong>只要一方未明确提出断开连接，则另一方保持 TCP 连接状态</strong></p>
<p>管线化是在持久连接的基础上实现的，管线化的实现，能够<strong>同时并行发送多个请求</strong>，而不需要一个接一个的等待响应</p>
<h3 id="HTTPS对称加密和非对称加密"><a href="#HTTPS对称加密和非对称加密" class="headerlink" title="HTTPS对称加密和非对称加密"></a>HTTPS对称加密和非对称加密</h3><ul>
<li>对称加密/共享密钥：<br>发送方和接收方需要持有同一把密钥，<strong>发送消息和接收消息均使用该密钥</strong>。相对于非对称加密，对称加密具有<strong>更高的加解密速度</strong>，但双方都需要事先知道密钥，密钥在传输过程中可能会被窃取，因此安全性没有非对称加密高。</li>
<li>非对称加密/公共密钥：<br>接收方在发送消息前需要事先生成公钥和私钥，然后将公钥发送给发送方。发送放收到公钥后，将待发送数据用公钥加密，发送给接收方。接收到收到数据后，用私钥解密。在这个过程中，<strong>公钥负责加密，私钥负责解密</strong>，数据在传输过程中即使被截获，攻击者由于没有私钥，因此也无法破解。非对称加密算法的加解密速度低于对称加密算法，但是<strong>安全性更高</strong>。</li>
</ul>
<p>参考<br><a href="https://juejin.im/post/5ca9de22e51d452b5372ed90" target="_blank" rel="noopener">三年大厂面试官-面试题精选及答案</a></p>
<h3 id="浏览器缓存？"><a href="#浏览器缓存？" class="headerlink" title="浏览器缓存？"></a>浏览器缓存？</h3><p>浏览器缓存机制的关键：</p>
<ul>
<li><p>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</p>
</li>
<li><p>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</p>
</li>
</ul>
<p>强缓存：不会向服务器发送请求，<strong>直接从缓存中读取资源</strong>，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：<strong>Expires</strong> 和 <strong>Cache-Control</strong>。<br>强制缓存的情况主要有三种：</p>
<ul>
<li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）<br><img src="https://img-blog.csdnimg.cn/20200308144107375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbGRnaXJseQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)<br><img src="https://img-blog.csdnimg.cn/20200308144118527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbGRnaXJseQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果<br><img src="https://img-blog.csdnimg.cn/20200308144149350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbGRnaXJseQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<p>协商缓存：就是强制缓存失效后，<strong>浏览器携带缓存标识向服务器发起请求</strong>，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p>
<ul>
<li>协商缓存生效，返回304和Not Modified<br><img src="https://img-blog.csdnimg.cn/20200308145028636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbGRnaXJseQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>协商缓存失效，返回200和请求结果<br><img src="https://img-blog.csdnimg.cn/20200308145043777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbGRnaXJseQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>协商缓存可以通过设置两种 HTTP Header 实现：<strong>Last-Modified</strong> 和 <strong>ETag</strong> 。</li>
</ul>
<p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。<br><img src="https://img-blog.csdnimg.cn/20200308144413363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbGRnaXJseQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>参考<br><a href="https://juejin.im/entry/5ad86c16f265da505a77dca4" target="_blank" rel="noopener">彻底理解浏览器的缓存机制</a></p>
<h3 id="get请求和post请求有什么区别？什么时候使用post"><a href="#get请求和post请求有什么区别？什么时候使用post" class="headerlink" title="get请求和post请求有什么区别？什么时候使用post?"></a>get请求和post请求有什么区别？什么时候使用post?</h3><p>GET：一般用于<strong>信息获取</strong>，使用 URL 传递参数，对所发送信息的<strong>数量也有限制</strong>，一般在 2000 个字符<br>POST：一般用于<strong>修改服务器上的资源</strong>，对所发送的信息<strong>没有限制</strong><br>区别：</p>
<ol>
<li>GET请求<strong>限制长度</strong>，POST没有限制。<br>实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对GET请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器<strong>限制了url的长度</strong>，因为数据量太大对浏览器和服务器都是很大负担。不同的浏览器和WEB服务器，限制的最大长度不一样。</li>
<li>GET和POST最大的区别主要是GET请求是<strong>幂等性</strong>的，POST请求不是。<br>幂等性是对同一URL的反复读取不应该对访问的数据有副作用。因为GET因为是读取，就可以对GET请求的数据做缓存。<br>不幂等也就意味着不能随意多次执行。多次执行会产生新资源，因此也就不能缓存。所以浏览器不能把POST请求保存为书签<br>所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有<strong>重复操作</strong>的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。</li>
<li>POST比GET<strong>安全</strong>，因为数据在地址栏上不可见<br>GET用URL传输数据，用户名和密码将明文出现在URL上，因为登录页面有可能被浏览器缓存，其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。POST虽然用body传输数据，但因为HTTP本身是明文协议。每个HTTP请求和返回都会在网络上明文传播，不管是url，header还是body。所以为了避免传输中数据被窃取，必须做从客户端到服务器的端端加密。业界的通行做法就是HTTPS。</li>
</ol>
<p>在以下情况中，请使用 POST 请求： </p>
<ol>
<li>无法使用缓存文件（更新服务器上的文件或数据库） </li>
<li>向服务器发送大量数据（POST 没有数据量限制） </li>
<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>
</ol>
<p>参考<br><a href="https://www.jianshu.com/p/fd67b576365d" target="_blank" rel="noopener">HTTP｜GET 和 POST 区别？网上多数答案都是错的</a></p>
<h3 id="Cookie详解"><a href="#Cookie详解" class="headerlink" title="Cookie详解"></a>Cookie详解</h3><p>cookie的应用场景</p>
<ul>
<li><p>在响应报文中服务器用Set-Cookie设定浏览器端要存储的Cookie信息，浏览器接受并保存，下次再访问同一个网站时，Web服务器接收到浏览器请求中携带的该Cookie信息，会<strong>依据Cookie里的内容来判断使用者，送出特定的网页内容</strong>。</p>
</li>
<li><p>网站可以利用cookie跟踪统计用户访问该网站的习惯，比如什么时间访问，访问了哪些页面，在每个网页的停留时间等。利用这些信息，一方面是可以为用户提供<strong>个性化服务</strong>，另一方面，也可以作为了解所有用户行为的工具，对于网站经营<strong>策略的改进</strong>有一定参考价值。</p>
</li>
<li><p>目前Cookie最广泛的是<strong>记录用户登录信息</strong>，这样下次访问时可以不需要输入自己的用户名、密码了——但容易发生用户信息泄密的问题，尤其在多个用户共用一台电脑时很容易出现这样的问题。</p>
</li>
</ul>
<p>Cookie的缺点</p>
<ul>
<li><p>安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。</p>
</li>
<li><p>并且每次你请求一个新的页面的时候，cookie只要满足作用域和作用路径，Cookie都会被发送过去，这样无形中<strong>浪费了带宽</strong>。</p>
</li>
</ul>
<p>参考<br><a href="https://segmentfault.com/a/1190000010400892" target="_blank" rel="noopener">cookie、sessionStorage、localStorage 详解及应用场景</a></p>
<h3 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别?"></a>Cookie 和 Session 的区别?</h3><ul>
<li>安全性： Session 比 Cookie 安全，<strong>Session 是存储在服务器端</strong>的，<strong>Cookie 是存储在客户端</strong>的。使用Cookie，别人可以分析存放在本地的Cookie并进行Cookie欺骗，考虑安全选择Session。使用Session当访问增多，会比较占用服务器的性能，考虑服务器性能选择Cookie。</li>
<li>存取值的类型：Cookie 只支持存<strong>字符串</strong>数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存<strong>任意数据类型</strong>。</li>
<li>有效期： Cookie 可设置为<strong>长时间</strong>保持，比如我们经常使用的默认登录功能，Session 一般<strong>时间较短</strong>，<strong>客户端关闭</strong>（默认情况下）或者 <strong>Session 超时</strong>都会失效。</li>
<li>存储大小： 单个 Cookie 保存的数据<strong>不能超过 4K</strong>，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li>
</ul>
<h3 id="Cookie、LocalStorage和SessionStorage-的区别"><a href="#Cookie、LocalStorage和SessionStorage-的区别" class="headerlink" title="Cookie、LocalStorage和SessionStorage 的区别"></a>Cookie、LocalStorage和SessionStorage 的区别</h3><p> Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</p>
<ol>
<li>储存位置：cookie 数据始终在同源的http请求中<strong>携带</strong>，<strong>服务器和客户端都可以访问</strong>。而 webStorage <strong>不会再请求中携带</strong>，仅仅在本地存储，只有<strong>本地浏览器端</strong>可访问数据，服务器不能访问本地存储直到通过POST或者GET的通道发送到服务器。</li>
<li>存储大小：cookie 是<strong>4k</strong>。webStorage 可以达到<strong>5M</strong>甚至更大</li>
<li>有效期： sessionStorage 仅仅是<strong>会话级别</strong>的存储，它只在当前浏览器关闭前有效，不能持久保持；localStorage <strong>始终有效</strong>，即使窗口或浏览器关闭也一直有效，除非用户手动删除，其才会失效；cookie 只在设置的 <strong>cookie 过期时间之前</strong>一直有效。</li>
<li>作用域：sessionStorage <strong>不在不同的浏览器窗口中共享</strong>； localStorage 和 cookie 在所有<strong>同源窗口是共享</strong>的。</li>
</ol>
<ul>
<li>sessionStorage“浏览器窗口”的概念：sessionStorage是在<strong>同源的同窗口</strong>中，始终存在的数据，也就是说只要这个浏览器窗口没有关闭，即使<strong>刷新页面</strong>或<strong>进入同源另一个页面</strong>，数据仍然存在，关闭窗口后，sessionStorage就会被销毁，同时<strong>“独立”打开的不同窗口，即使是同一页面</strong>，sessionStorage对象也是不同的。</li>
</ul>
<ol start="5">
<li>实际应用：Cookies最典型的应用是<strong>用户的登录信息</strong>，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是Cookies的功用。Web Storage存储一些需要<strong>页面共享</strong>的信息，并且不需要向后台发送的信息。</li>
<li>web storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。</li>
<li>Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200308162752758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbGRnaXJseQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>参考<br><a href="https://www.jianshu.com/p/bdbae99a3871" target="_blank" rel="noopener">cookie、session、sessionStorage、localStorage区别</a><br><a href="https://segmentfault.com/a/1190000015015258" target="_blank" rel="noopener">Cookie、SessionStorage、LocalStorage应用及区别</a></p>
<h3 id="基于-Token-的身份验证方法"><a href="#基于-Token-的身份验证方法" class="headerlink" title="基于 Token 的身份验证方法"></a>基于 Token 的身份验证方法</h3><ol>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务器端收到请求，去验证用户名与密码，验证成功后，服务器端会<strong>签发一个 token 并把这个 token 发送给客户端</strong></li>
<li>客户端收到 token 以后，会把它存储起来，比如放在 <strong>cookie</strong> 里或者 <strong>localStorage</strong> 里，客户端每次向服务器端<strong>请求资源</strong>的时候需要带着服务器端签发的 token</li>
<li>服务器端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端<strong>返回请求的数据</strong></li>
</ol>
<ul>
<li><strong>每一次请求都需要携带 token</strong>，需要把 token 放到 HTTP 的 <strong>Header</strong> 里</li>
<li>基于 token 的用户认证是一种<strong>服务端无状态</strong>的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而<strong>减轻服务器的压力</strong>，减少频繁的查询数据库</li>
<li>token 完全由应用管理，所以它可以<strong>避开同源策略</strong></li>
</ul>
<p>对比基于Cookie的认证</p>
<ol>
<li>客户端把用户 ID 和密码等登录信息放入报文的实体部分,通常是以 POST 方法把请求发送给服务器。</li>
<li>服务器会发放用以识别用户的 <strong>Session ID</strong>并将其存在Session中。在首部字段 Set-Cookie 内写入 Session ID</li>
<li>客户端接收到从服务器端发来的 Session ID 后,会将其作为 <strong>Cookie</strong> 保存在本地</li>
<li>下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的Session ID 识别用户和其认证状态<br><img src="https://img-blog.csdnimg.cn/20200308200616228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbGRnaXJseQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<p>同源策略在web应用的安全模型中是一个重要概念，同源指<strong>协议</strong>，<strong>域名</strong>，<strong>端口</strong>相同。在这个策略下，web浏览器<strong>只有在两个页面有相同的源时，才允许第一个页面的脚本访问第二个页面里的数据</strong>。这个策略可以阻止一个页面上的恶意脚本通过页面的DOM对象获得访问另一个页面上敏感信息的权限。</p>
<p>参考<br><a href="https://www.cnblogs.com/xiekeli/p/5607107.html" target="_blank" rel="noopener">几种常用的认证机制</a></p>
<h3 id="XSS和CSRF区别"><a href="#XSS和CSRF区别" class="headerlink" title="XSS和CSRF区别"></a>XSS和CSRF区别</h3><ul>
<li>跨站脚本攻击（Cross Site Scripting)，恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页或点击、输入触发时，<strong>嵌入其中 Web 里面的 Script 代码会被执行</strong>，从而达到恶意攻击用户的目的。（攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如cookie)的脚本。）</li>
<li>跨站请求伪造（Cross-site request forgery），是伪造请求，<strong>冒充用户在站内的正常操作</strong>。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。</li>
</ul>
<p>区别：</p>
<ol>
<li>原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注入JS代码，然后执行JS里的代码。</li>
<li>CSRF需要用户先<strong>登录目标网站获取cookie</strong>，而XSS<strong>不需要登录</strong></li>
<li>CSRF的目标是用户，XSS的目标是服务器</li>
<li>XSS是<strong>利用合法用户获取其信息</strong>，而CSRF是<strong>伪造成合法用户发起请求</strong></li>
</ol>
<p>XSS 攻击的防范</p>
<ol>
<li>HttpOnly 防止劫取 Cookie<br>HttpOnly 使浏览器禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。设置之后从 Web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的 document.cookie就无法读取附加 HttpOnly 属性后的 Cookie 的内容。<br>攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。</li>
<li>输入检查<br>不要相信用户的任何输入。 对于用户的任何输入要进行<strong>检查、过滤和转义</strong>。<strong>建立可信任的字符和 HTML 标签白名单</strong>，对于不在白名单之列的字符或者标签进行过滤或编码。<br>在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 &lt;，&gt; 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。<br>而在一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 &lt;，&gt;，script，防止 XSS 攻击 </li>
<li>输出检查<br>用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用<strong>编码或转义</strong>的方式来防御 XSS 攻击。例如利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。</li>
</ol>
<p>CSRF 攻击的防范</p>
<ol>
<li><p>验证码<br>验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会<strong>强制用户必须与应用进行交互，才能完成最终请求</strong>。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。</p>
</li>
<li><p>Referer Check<br>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它<strong>记录了该 HTTP 请求的来源地址</strong>。通过 Referer Check，可以检查请求是否来自合法的”源”。比如，如果用户要删除自己的帖子，那么先要登录 <a href="http://www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer" target="_blank" rel="noopener">www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer</a> 的值是 <a href="http://www.c.com；当请求是从" target="_blank" rel="noopener">http://www.c.com；当请求是从</a> <a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a> 发起时，Referer 的值是 <a href="http://www.a.com" target="_blank" rel="noopener">http://www.a.com</a> 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 <a href="http://www.c.com" target="_blank" rel="noopener">www.c.com</a> 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。<br>Referer Check 不仅能防范 CSRF 攻击，另一个应用场景是 “防止图片盗链”。</p>
</li>
<li><p>添加 token 验证<br>CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于<strong>在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。</strong>可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
</li>
</ol>
<p>参考<br><a href="https://github.com/dwqs/blog/issues/68" target="_blank" rel="noopener">浅说 XSS 和 CSRF</a></p>
<p>参考资料</p>
<ul>
<li><p><a href="https://juejin.im/post/5ba34e54e51d450e5162789b" target="_blank" rel="noopener">2万5千字大厂面经</a></p>
</li>
<li><p>《图解HTTP》</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cjycathy.github.io/2020/03/28/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94HTTP%E9%83%A8%E5%88%86/" data-id="ck8bm6p2q0001hguee7z4guq1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/28/hello-world/" class="article-date">
  <time datetime="2020-03-28T09:22:19.138Z" itemprop="datePublished">2020-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/28/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cjycathy.github.io/2020/03/28/hello-world/" data-id="ck8bm6p2j0000hgue1ese41hc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/28/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94HTTP%E9%83%A8%E5%88%86/">Web前端面试——HTTP部分</a>
          </li>
        
          <li>
            <a href="/2020/03/28/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Jinyi Cai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>